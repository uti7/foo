<?xml version="1.0" encoding="shift_jis" ?>
<?component error="True" debug="True"?>  
<component>

<registration
	description="WSC Skeleton"
	progid="Coldspa.COM"
	version="1.00"
	classid="{766F453F-0184-49A0-8EB6-30579CB55BEF}"
>
</registration>

<public>

<comment>
************************************************************
* プロパティ
************************************************************
</comment>
	<property name="Clipboard">
		<get/>
		<put/>
	</property>
	<property name="ScriptDir">
		<get/>
		<put/>
	</property>
	<property name="LastError">
		<get/>
	</property>
	<property name="testStr">
		<get/>
		<put/>
	</property>

<comment>
************************************************************
* メソッド
************************************************************
</comment>
	<method name="selectXML">
		<PARAMETER name="xpath"/>
		<PARAMETER name="file"/>
	</method>
	<method name="selectXMLs">
		<PARAMETER name="xpath"/>
		<PARAMETER name="file"/>
	</method>
	<method name="selectXML2JSON">
		<PARAMETER name="xpath"/>
		<PARAMETER name="file"/>
	</method>
	<method name="loadXML">
		<PARAMETER name="file"/>
	</method>
	<method name="makeAccountList"/>
	<method name="isNWAvailable"/>
	<method name="isJustAwoke"/>
	<method name="extractMail">
		<PARAMETER name="id"/>
		<PARAMETER name="parent"/>
		<PARAMETER name="folder"/>
		<PARAMETER name="mime"/>
	</method>
	<method name="vbs">
		<PARAMETER name="script"/>
	</method>
	<method name="gvbs">
		<PARAMETER name="script"/>
	</method>
	<method name="vbsAsync">
		<PARAMETER name="script"/>
	</method>
	<method name="js">
		<PARAMETER name="script"/>
	</method>
	<method name="json">
		<PARAMETER name="str"/>
	</method>
	<method name="jMatch">
		<PARAMETER name="str"/>
		<PARAMETER name="restr"/>
		<PARAMETER name="flags"/>
		<PARAMETER name="retpos"/>
	</method>
	<method name="jReplace">
		<PARAMETER name="str"/>
		<PARAMETER name="restr"/>
		<PARAMETER name="replaced"/>
		<PARAMETER name="flags"/>
	</method>
	<method name="doTweet">
		<PARAMETER name="mono"/>
	</method>
	<method name="getTweetByUser">
		<PARAMETER name="user"/>
		<PARAMETER name="count"/>
	</method>
	<method name="translateText">
		<PARAMETER name="mono"/>
		<PARAMETER name="toLang"/>
	</method>
	<method name="searchIdx">
		<PARAMETER name="fol"/>
		<PARAMETER name="kwstr"/>
		<PARAMETER name="workdir"/>
		<PARAMETER name="d1"/>
		<PARAMETER name="d2"/>
	</method>
	<method name="discardIdx">
		<PARAMETER name="fol"/>
		<PARAMETER name="workdir"/>
	</method>
	<method name="baspW3getEx">
		<PARAMETER name="url"/>
		<PARAMETER name="outfile"/>
		<PARAMETER name="intype"/>
		<PARAMETER name="outtype"/>
	</method>
	<method name="setWorkInProgress">
		<PARAMETER name="type_"/>
		<PARAMETER name="id"/>
		<PARAMETER name="listfile"/>
		<PARAMETER name="workdir"/>
	</method>
	<method name="utf8headerDecode">
		<PARAMETER name="file"/>
	</method>
	<method name="myBase64Decode">
		<PARAMETER name="sFile"/>
		<PARAMETER name="dFile"/>
	</method>
</public>


<object id="basp" progid="Basp21" />
<object id="fso"  progid="Scripting.FileSystemObject" />
<object id="sh"  progid="WScript.Shell" />
<object id="shapp"  progid="Shell.Application" />
<script language="JScript">
<![CDATA[
	//
	function jMatch(str, restr, flags, retpos)
	{
		// jsによる正規表現マッチ(VBSのRegExpはめんどくさいのでVBSからこれを呼ぶ）
		// 戻り
		// * マッチした場合
		// - reposが数の場合: その場所のマッチ文字
		// 		(0:マッチ全体, 1...9 サブマッチ)
		//   注1：VBS側では 戻りを If r Then などと判定すると
		//        マッチしている場合にエラーになるので注意
		//        If r <> False Then なら OK
		// 
		// - retposがEmpty(undefined)など数以外の時: true
		//
		// * マッチしなかった場合: 常にfalse
		//
		if(flags == undefined){
			flags = "ig";
		}
		var re = new RegExp(restr, flags);
		var matches =  re.exec(str);
		var ret = false;
		//WScript.Echo("J typeof(retpos)=val:" + typeof(retpos) + "=" + retpos)
		if(matches){
			if(typeof(retpos) == "number"){
				ret = (matches[retpos]) ? matches[retpos] : "";
			}else{
				ret = true;
			}
		}else{
			ret = false
		}
		//WScript.Echo("J typeof(ret)=val:" + typeof(ret) + "=" + ret);
		return ret;
	}

	function jReplace(str, restr, replaced, flags)
	{
		if(!flags){
			flags = "ig";
		}
		var re = new RegExp(restr, flags);
		var ret = str.replace(re, replaced);

		return ret;
	}

	// ************************************************
	function js(script){
		// 引数文字をｊｓとして実行する。評価値を返す
		if(!script){
			return ""
		}

		return eval(script);
		//return script;
	}

	function json(str){
		// 引数文字をjsonとして評価しオブジェクトとして返す
		// 戻りはahk,vbsのオブジェクトとして使用できる
		// 上記の js でやろうとすると↓する必要があるため
		//      js("function foo() { return {foo:"1",bar:['hoge', 3]}; } foo();")
		// スカラのプロパティは r.foo でもOK だが
		// 配列は VBSならr.bar.[0] AHKなら r["bar"][0] とする必要がある
		// jsの基底メソッドが使える↓
		// 			r["bar"].length // .. is 2
		// jsonでなくても r に代入できるjsのobjectであればなんでも使えるはず
		// （空文字や "{}" を評価して返すと
		// ahk側では IsObject()=真であるものの、ret["bar"] などとプロパティ参照した
		// ときahkがエラーになるため。空文字なら ないプロパティを参照しようとしてもエラーにならない
		// 最上位レベルのプロパティならgetterで取得できるようにした
		// しかし ahkからはみれないorz
		if(!str || /^\s*[{]\s*[}]\s*$/.test(str)){
			return ""
		}
		eval("r="+str);

/*
		// getter 
		r.setProperties = function setProperties(into, from) {
			if (into != null && from != null) {
					for (var key in from) {
							into[key] = from[key];
					}
			}
			return into;
		}
		r.setProperties(r, // utility functions
		{ getv:  function getv(p){ if(this[p]){return this[p];}else{return "no";} } });
*/
		//r.test = function test(p){ if(this[p]){return this[p];}else{return "no";} }
		return r;
	}

	/* 非公開 */
	function json_enc_(s)
	{
		s = s.replace(/'/g, '\\0027');
		s = s.replace(/"/g, '\"');
		s = s.replace(/\{/g, '\\007b');
		s = s.replace(/\}/g, '\\007d');
		s = s.replace(/\[/g, '\\005b');
		s = s.replace(/\]/g, '\\005d');
		s = s.replace(/\r/g, '\\r');
		s = s.replace(/\n/g, '\\');
		s = s.replace(/\\/g, '\\');
		return s;
	}

]]></script>
<script language="VBScript"><![CDATA[
Option Explicit
Function utf8qp(buf)
Dim re
Dim code
Dim code1
Dim code2
Dim code3
Dim k
Dim Text

Set re=New RegExp
re.IgnoreCase=True
re.Global=True

re.Pattern="=\r\n"
buf=re.Replace(buf,"")
re.Pattern="=([0-9A-F][0-9A-F])"
buf=re.Replace(buf,GetRef("rep"))

For k=1 To Len(buf)
  code=AscW(Mid(buf,k,1))
  If 0<=code And code<128 Then
    Text=Text&Chr(code)
  ElseIf 128+64<=code And code<128+64+32 Then
    code1=code
    k=k+1
    code2=AscW(Mid(buf,k,1))
    code=(code1 And &H1F) * 64 + (code2 And &H3F)
    If Chr(Asc(ChrW(code)))=ChrW(code) Then
      Text=Text & ChrW(code)
    Else
      Text=Text & "{" & Right(Hex(code1+256),2) &"}{"& Right(Hex(code2+256),2) &"}"
    End If
  ElseIf 128+64+32<=code And code<128+64+32+16 Then
    code1=code
    k=k+1
    code2=AscW(Mid(buf,k,1))
    k=k+1
    code3=AscW(Mid(buf,k,1))
    code=(code1 And &H0F) * 16 * 256 + (code2 And &H3F) * 64 + (code3 And &H3F)
    If Chr(Asc(ChrW(code)))=ChrW(code) Then
      Text=Text & ChrW(code)
    Else
      Text=Text & "{" & Right(Hex(code1+256),2) &"}{"& Right(Hex(code2+256),2) &"}{"& Right(Hex(code3+256),2) &"}"
    End If
  Else
    If Chr(Asc(ChrW(code)))=ChrW(code) Then
      Text=Text & ChrW(code)
    Else
      Text=Text & "{" & Escape(ChrW(code)) &"}"
    End If
  End If
Next
utf8qp=Text
End Function

Function rep(match,submatch,pos,source)
rep=ChrW(CLng("&H" & submatch))
End Function

Function doMimeDecode(ByRef value)
  Dim u, res, i, b64, fileA, fileB, dts
  u = basp.MatchEx("/(=\?UTF-8\?B\?[^?]+\?=)/ikg", value, 1)

  If IsArray(u) Then
    ' UTF-8+MIME+BASE64
'Stop
    fileA = basp.GetTempFile() 
    fileB = basp.GetTempFile() 
    For i = 0 To UBound(u)
      b64 = basp.Match("/=\?UTF-8\?B\?([^?]+)\?=/ik", u(i))
      If fso.FileExists(fileA) Then
        Call fso.DeleteFile(fileA, True)
      End If
      If fso.FileExists(fileB) Then
        Call fso.DeleteFile(fileB, True)
      End If
      res = basp.BinaryWrite(basp.ByteArray(b64), fileA)
      '↑fso使うよりファイル化が気休め程度に楽なのでByteArrayにしている
      'res = basp.Base64(fileA & vbTab & fileB, 7)
      res = myBase64Decode(fileA, fileB)
      res = basp.KconvFile(fileB, fileA, 1, 5)  'Shif_JISに
      Set dts = fso.OpenTextFile(fileA, 1, False)
      res = dts.ReadAll
      dts.Close
      value = Replace(value, u(i), res, 1, 1)
    Next
    value = basp.Replace("s/\s+/ /g", value)
    doMimeDecode = True
    Exit Function
	Else
		u = basp.MatchEx("/(=\?UTF-8\?Q\?[^?]+\?=)/ikg", value, 1)
		If IsArray(u) Then
			' UTF-8+MIME+QuotedPrintable
			value = ""
			For i = 0 To UBound(u)
				b64 = basp.Match("/=\?UTF-8\?Q\?([^?]+)\?=/ik", u(i))
				value = value & utf8qp(b64)
			Next
			doMimeDecode = True
			Exit Function
		End If
  End If
  'i.e. doMimeDecode = False
End Function

Class searchResults
    Sub Class_Initialize()
			nField = 0
			fromStmt = ""
			whereStmt = ""
    End Sub

    Sub Class_Terminate()
    End Sub

		Sub init(cn_)
			Set cn = cn_
			cn.Execute("DELETE FROM hit WHERE 1;")
		End Sub

		Sub registField(fld)
			If nField = 0 Then
				fromStmt = "hit as t" & nField
				whereStmt = "t" & nField & ".fieldName = '" & fld & "'"

			ElseIf nField = 1 Then
				fromStmt = fromStmt & " INNER JOIN hit as t" & nField _
				& " ON t" & nField-1 & ".id = t" & nField & ".id"
				whereStmt = whereStmt & " AND t" & nField & ".fieldName = '" _
				& fld & "'"

			Else
				fromStmt = "hit as t" & nField & " INNER JOIN (" & fromStmt _
				& ") ON t" & nField-1 & ".id = t" & nField & ".id"
				whereStmt = whereStmt & " AND t" & nField & ".fieldName = '" _
				& fld & "'"

			End If

			nField = nField + 1
		End Sub

		Sub entry(id, fieldName, fieldDate)
			Dim rs
'Stop
			Set rs = cn.Execute("SELECT id FROM hit WHERE id = '" _
			& id & "' AND fieldName = '" & fieldName & "'")
			If rs.BOF Or rs.EOF Then
				cn.Execute("INSERT INTO hit (id, fieldName, fieldDate) VALUES('" _
				& id & "', '" & fieldName & "', '" & fieldDate & "')")
			End If
		End Sub

		Function whereIDstr()
			If hitid Is Nothing Then
				whereIDstr = ""
				Exit Function
			End If
			Dim ret,id,ids
			ids = hitid.Keys()
			ret = "IN( "
			For Each id In ids
				ret = ret & "'" & id & "', "
			Next
			ret = basp.Replace("s/,\s*$//", ret) & ")"
		End Function

		Private hitid
		Private cn
		Private nField
		Public fromStmt
		Public whereStmt
End Class

Function retrievalFromDB(id, dest)
	' 2012-03-30 メールファイルがなくても(サイズ0含む）DBにあれば
	' 復元しextractで見れる（添付ファイルはDBにないため復元不可能）
	If fso.FileExists(id) Then
		If fso.GetFile(id).Size > 0 Then
			retrievalFromDB =  False	' ファイル内容ある。普通にextract
			Exit Function
		End If
	End If

	' ファイルないor空。DBにあれば復元

  Dim id_: id_ = basp.Match("/.*\\(.*)$/ik", id) ' get uidx

	'インデックスに接続
	Dim cn, sql, rs
	Set cn = CreateObject("ADODB.Connection")
	cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
					 "Data Source=coldspa.mdb;"
	sql = "SELECT fieldName, content FROM mail"_
			& " WHERE id='" & id_ & "'" _
			& " ORDER BY partNo"
	Set rs = cn.Execute(sql)

	Dim hbuf, bbuf, ots
	hbuf = "": bbuf = ""
	Do While Not rs.BOF And  Not rs.EOF
		If rs("fieldName").Value = "Body" Then
			bbuf = bbuf & rs("content").Value
		Else
			hbuf = hbuf & rs("fieldName").Value & ": " & rs("content").Value & vbCrLf
		End If
		rs.MoveNext
	Loop
	cn.Close

	If Len(hbuf) > 0 Then
    Set ots = fso.OpenTextFile(dest & "\header.txt", 2, True)
		ots.Write hbuf
		ots.Close
		If Len(bbuf) > 0 Then
			Set ots = fso.OpenTextFile(dest & "\body.txt", 2, True)
			ots.Write bbuf
			ots.Close
		Else
			'headerがあれば body が空でも空bodyファイル作成
			fso.OpenTextFile(dest & "\body.txt", 2, True).Close
		End If
	End If
	retrievalFromDB = True
End Function

]]></script>
<script language="VBScript">
<![CDATA[
Option Explicit
Dim ScriptDir
Dim ErrorMessage
Dim extractDir

' ************************************************
' プロパティ処理の実装
' ************************************************
' --------------------------------------
' クリップボード
' --------------------------------------
function get_Clipboard()

	Dim objIE

	Set objIE = CreateObject("InternetExplorer.Application")
	objIE.Navigate("about:blank")
	get_Clipboard = objIE.document.parentwindow.clipboardData.GetData("Text")
	objIE.Quit
	Set objIE = Nothing

end function
function put_Clipboard(srt)

	Dim objIE

	Set objIE = CreateObject("InternetExplorer.Application")
	objIE.Navigate("about:blank")
	objIE.document.parentwindow.clipboardData.SetData "Text", srt
	objIE.Quit
	Set objIE = Nothing

end function
' --------------------------------------
' スクリプトディレクトリの保存
' ScriptDir = WScript.ScriptFullName
' を必ず実行してから ScriptDir プロパティ
' を使用する
' --------------------------------------
function get_ScriptDir()

	get_ScriptDir = ScriptDir

end function
function put_ScriptDir(str)

	Dim obj

	ScriptDir = str
	Set obj = fso.GetFile( ScriptDir )
	Set obj = obj.ParentFolder
	ScriptDir = obj.Path

	sh.CurrentDirectory = ScriptDir

end function
' --------------------------------------
' 直近に発生したエラーメッセージ
' --------------------------------------
function get_LastError()

	get_LastError = ErrorMessage

end function

Dim t
Function get_testStr()
	get_testStr = t
End Function
Function put_testStr(s)
	t = s
End Function

' ************************************************
' ************************************************
Function dspParseErr(e,doQuery)

    If doQuery Then
        dspParseErr = MsgBox("an error has occured while parse this file." _
            & vbCrLf & vbCrLf _
            & "line: " & e.Line & " column: " & e.linepos & vbCrLf _
            & "source: " & omitSrc(e.srcText, e.linepos, 20, 20) & vbCrLf & vbCrLf _
            & e.reason & vbCrLf & vbCrLf & e.url & vbCrLf & vbCrLf & _
            "continue?", vbExclamation + vbYesNo, "cold spa")
    Else
        Call MsgBox("an error has occured while parse this file." & vbCrLf & vbCrLf _
            & "line: " & e.Line & " column: " & e.linepos & vbCrLf _
            & "source: " & omitSrc(e.srcText, e.linepos, 20, 20) & vbCrLf & vbCrLf _
            & e.reason & vbCrLf &  vbCrLf & _
            e.url, vbCritical, "cold spa")

            '2004-04-20
            dspParseErr = vbNo
    End If

End Function

Function omitSrc(srcTxt, positionCol, _
                        leftMaxCol, rightMaxCol)
    ' NOTE: positioncol: 1-origin

    If srcTxt = "" Then Exit Function

    If positionCol < leftMaxCol Then
        omitSrc = left(srcTxt, positionCol - 1)
    ElseIf positionCol = leftMaxCol Then ' 2004-07-06 utiumi 同じ値の場合 0 からｍｉｄしようとして落ちる
        omitSrc = "... " & Mid(srcTxt, 1, leftMaxCol - 1)
    Else
        omitSrc = "... " & Mid(srcTxt, positionCol - leftMaxCol, leftMaxCol)
        'omitSrc = "... " & Mid(srcTxt, positionCol - leftMaxCol, positionCol - leftMaxCol - 1)
        'positionCol - leftMaxCol
    End If
    omitSrc = omitSrc & " *ERROR* "

    If Len(srcTxt) - positionCol > rightMaxCol Then
        omitSrc = omitSrc & Mid(srcTxt, positionCol, rightMaxCol) & " ..."
    Else
        omitSrc = omitSrc & Mid(srcTxt, positionCol, Len(srcTxt))
    End If
End Function

Function getTmpDir()
  ' 2008-03-31 configの値を見ないので注意
  getTmpDir = sh.ExpandEnvironmentStrings("%TEMP%") _
            & "\coldspa\_tmp"
End Function

Sub progressLog(msg)
  Dim ts
  'プログレスバーのdelay表示用にファイル出力
  Set ts = fso.OpenTextFile(getTmpDir() & "\progress.sts", 2, True)
  ts.WriteLine msg
  ts.Close
End Sub

Function lookup_(key, collection_obj)
  ' コレクション検索
    Dim o
    For Each o In collection_obj
        If o = key Then ' compare key and default property value of the obj
            Set lookup_ = o
            Exit Function
        End If
    Next
    Set lookup_ = Nothing
End Function

' 2009-06-07
Function determinedBody(ctp, ctenc, bodystr, file)
  '本文の文字を返すフロント（UTF-8なら生データ解析する）
  Dim isUTF8, isQuotedPrintable, isBase64, mp_boundary, f

'Stop
  'ファイルサイズが大きいと下のbasp.MatchExでこけるのでなにもしないように
  If fso.GetFile(file).Size > 5 * 1024 * 1024 Then
    determinedBody = basp.Replace("s/^Body: //i", bodystr)
    sh.Popup "its too large, mail body will not determined.", 2, "coldspa", 48
    Exit Function
  End If

'Stop
  If IsEmpty(ctp) Then
    ctp = "dummy" ' 2009-06-12 Emptyや空文字だとinvalid target parameterになるのを防止
  End If
  If IsEmpty(ctenc) Then
    ctenc = "dummy" ' 2009-06-12 Emptyや空文字だとinvalid target parameterになるのを防止
  End If

  If basp.Match("/charset=\x22?utf-8\x22?;?/ik", ctp) <> "0" Then
    isUTF8 = True
    If basp.Match("/quoted-printable/ik", ctenc) <> "0" Then
      isQuotedPrintable = True
    ElseIf basp.Match("/base64/ik", ctenc) <> "0" Then
      isBase64 = True
    End If
  Else
   mp_boundary = basp.Match("/multipart.*;\s*boundary=""?([^""]*)""?/ik", ctp)
  End If

  If isUTF8 Or mp_boundary <> "0" Then

		Const adTypeText = 2
		Const adTypeBinary = 1
		Const adSaveCreateOverWrite = 2
		Const adSaveCreateNotExist = 1
		Const adReadAll = -1
		Const adReadLine = -2

    Dim ts, buf, s
		' 2012-10-21 for plane utf-8
    ' Set ts = fso.OpenTextFile(file, 1, False)
    ' buf = ts.ReadAll
    ' ts.Close
		Set ts = CreateObject("ADODB.Stream")
		ts.Type = adTypeText
		ts.Charset = "UTF-8"
		ts.Open
		ts.LoadFromFile(file)
    buf = ts.ReadText(adReadAll)
		ts.Close

'basp.Debug "isUTF8(determined)=" & isUTF8 & ", buf=" & buf

    s = Split(buf, vbCrLf & vbCrLf, 2)'ヘッダを除きたい
    buf = s(1)  'ボディ
    determinedBody = getBodyBySelf(isUTF8, isQuotedPrintable, isBase64, mp_boundary, buf, bodystr)
    Exit Function
  End If
  determinedBody = basp.Replace("s/^Body: //i", bodystr)
End Function

Function getBodyBySelf(isUTF8, isQuotedPrintable, isBase64, mp_boundary, buf, orgbody)
  '生データから本文の文字を返す
  Dim fileA, fileB, res, ts
	' 2012-11-11 multi part を先に判定する
  If mp_boundary <> "0" Then
    Dim parts, p, concat, h, isUTF8_sub, mp_boundary_sub

    ' 2009-06-11 ファイルが1MBでもbasp.Splitでwscriptがこける
    ' boundaryに正規表現メタ文字があるときがあるのでエスケープ。全掌握してない
    'mp_boundary = basp.Replace("s/([?+*.])/\\$1/ikg", mp_boundary)
'Stop
    'parts = basp.Split("/--" & mp_boundary & "(--)?\r?\n/", buf)
		' 2010-02-17 正規表現splitやめたが本文最後のboundaryの後ろには「--」がある？
		' 2009-06-17 ある場合splitされずにそのまま残っているのでLeftで消す
    parts = Split(buf, "--" & mp_boundary & vbCrLF)
		p = InStrRev(parts(UBound(parts)), "--" & mp_boundary & "--")
		If p > 0 Then
			parts(UBound(parts)) = Left(parts(UBound(parts)), p-1)
		End If

    concat = ""
    For Each p In parts
'basp.Debug Len(p)
      ' 2009-06-11 パートが巨大だとbasp.Matchでこける
      If Len(p) > 1024 * 512 Then
        h = "0"
      ElseIf Len(p) = 0 Then
				'やらずともMatchでinvalid target parameterになるので結果オーライだが
				h = "ignore"
      Else
        h = basp.Match("/^(\r\n|\s)*$/", p)
      End If

      If h = "0" Then
        'ヘッダを分離（最初の空行まで）
        h = Split(p, vbCrLf & vbCrLf, 2)
				
        If InStr(1, p, vbCrLf) = 1 Then
          'パートが改行で始まっている＝ヘッダがない
          concat = concat & vbCrLf & "## start of no header part" & vbCrLf &  p & vbCrLf & "## end of no header part" & vbCrLf & vbCrLf

        '添付でないtext/plain（更にｍｐなら再帰的に）そのパートを連結
        ElseIf basp.Match("/Content-Type:\s+text\/plain/ik", h(0)) <> "0" _
        And basp.Match("/Content-Disposition:\s+attachment;?/ik", h(0)) = "0" Then
          isUTF8_sub = (basp.Match("/charset=\x22?utf-8\x22?;?/ik", h(0)) <> "0")
          If Not isUTF8_sub Then
'Stop
            If basp.Match("/charset=\x22?ISO-2022-JP\x22?;?/ik", h(0)) <> "0" _
            And basp.Match("/Content-Transfer-Encoding:\s+quoted-printable/ik", h(0)) = "0" Then

              isUTF8_sub = 6  'kconvのintypeで使う値
            ElseIf basp.Match("/charset=\x22?us-ascii\x22?;?/ik", h(0)) <> "0"Then
              isUTF8_sub = 4  'kconvのintypeで使う値 4（ucs2）は結果変換されない
            End If
          End If
          If isUTF8_sub Then
            concat = concat & getBodyBySelf( _
            isUTF8_sub, _
            (basp.Match("/Content-Transfer-Encoding:\s+quoted-printable/ik", h(0)) <> "0"), _
            (basp.Match("/Content-Transfer-Encoding:\s+base64/ik", h(0)) <> "0"), _
          "0", h(1), h(1)) '最後の引数にorgbodyを使うとUTF化けもconcatされるので
          Else
            'iso2022-jp, utf-8 でなければ呼ばない
'Stop
            concat = concat & orgbody 'Body:もあえて取らない
          End If
' FIXME: 展開済みファイルをfsoのReadで読もうとしてもnative文字コードでないと化ける
        ElseIf basp.Match("/Content-Type:\s+text\//ik", h(0)) <> "0" _
        And basp.Match("/Content-Disposition:\s+attachment;?/ik", h(0)) <> "0" Then
          'テキストファイルの添付なら
          'filenameを見てbaspによって展開済みの実ファイルを読み
          '行頭ピリオドを復元
          Dim filename, abuf, bbuf, org_filename, i
          filename = basp.Match("/filename=\x22?([^\x22]+)\x22?/ik", h(0))
'Stop
          org_filename = extractDir & "\org_" & filename
          filename = extractDir & "\" & filename
          If fso.FileExists(filename) Then
            fso.MoveFile filename, org_filename
            abuf = basp.BinaryRead(org_filename)

            bbuf = basp.SplitB("/\r\n\.\./", abuf)
            For i = 0 To UBound(bbuf)
              If i = UBound(bbuf) Then
                Call basp.BinaryWrite(bbuf(i), filename, 1)
              Else
                Call basp.BinaryWrite(basp.BinaryConcat(bbuf(i), _
                  basp.ByteArray(vbCrLf & ".")) , filename, 1)
              End If
            Next
            
          End If
        ElseIf basp.Match("/Content-Type:\s+message\/delivery-status/ik", h(0)) <> "0" Then
          ' 2009-06-17 メールサーバーの通知
          concat = concat & h(1)

        ElseIf basp.Match("/Content-Type:\s+text\/html/ik", h(0)) <> "0" Then
					If concat = "" Then
						' 2010-02-17 multi/altでplainがなくhtmlだけがあると
						' ReadMailでmail.htmが生成されないのでここでbodyとして表示させる
          	concat = "<!--## altanative text missing ##-->" _
										& vbCrLf & vbCrLf & h(1)
					End If
        Else
          mp_boundary_sub = basp.Match("/multipart.*;\s*boundary=""([^""]*)""/ik", h(0))
          If mp_boundary_sub <> "0" Then
            concat = concat & getBodyBySelf(False, False, False, _
              mp_boundary_sub, h(1), orgbody)
          End If
        End If
      Else
        ' 2009-06-17 空パート
      End If
    Next

    getBodyBySelf = concat
    Exit Function

'basp.Debug "isUTF8(entry)=" & isUTF8 & ", buf=" & buf
  ElseIf isUTF8 Then
    If isUTF8 > 0 Then
      '自力でiso2022-jpなど変換
'basp.Debug "isUTF8(>0)=" & isUTF8 & ", buf=" & buf
      getBodyBySelf = basp.Kconv(buf, 4, isUTF8)
      Exit Function

    ElseIf isQuotedPrintable Then
      getBodyBySelf = utf8qp(buf)
      Exit Function

    ElseIf isBase64 Then
      'getBodyBySelf = basp.Kconv(basp.Base64(buf, 1), 1, 5)
      '↑バイト配列になる、かつ変換結果もおかしい
      'で、ファイルでやる
      fileA = basp.GetTempFile() 
      fileB = basp.GetTempFile() 
      res = basp.BinaryWrite(basp.ByteArray(buf), fileA)
      '↑fso使うよりファイル化が気休め程度に楽なのでByteArrayにしている
      res = basp.Base64(fileA & vbTab & fileB, 7)
      res = basp.KconvFile(fileB, fileA, 1, 5)  'Shif_JISに
      Set ts = fso.OpenTextFile(fileA, 1, False)
      getBodyBySelf = ts.ReadAll
      ts.Close
      Exit Function

		Else
			' 2012-10-23 plane utf-8
'basp.Debug "isUTF8(?)=" & isUTF8 & ", buf=" & buf
			getBodyBySelf = basp.Replace("s/^Body: //i", buf)
      Exit Function
    End If
  End If
  getBodyBySelf = basp.Replace("s/^Body: //i", orgbody)
End Function

Function registIdx(id, parent, folName, fieldDate, dat)
' 2009-06-26 抽出したメールを全文検索インデックスへ登録
	Dim cn, rs, sql, id_, parent_, flds, d, rcvDate, i

  id_ = basp.Match("/.*\\(.*)$/ik", id) ' get uidx
  If InStr(1, id_, "rfc822") Then
    '添付メール
    id_ = basp.MD5(id, 1) ' 添付メールネスト対策
	End If

	If parent = 0 Then
		'最親の通常メール
		rcvDate = fso.GetFile(id).DateLastModified
		parent_ = ""
	Else
		rcvDate = fso.GetFile(parent).DateLastModified

		'添付メール
		parent_ = basp.Match("/.*\\(.*)$/ik", parent) ' get uidx
		If InStr(1, parent_, "rfc822") Then
			'添付メール
			parent_ = basp.MD5(parent, 1) ' 添付メールネスト対策
		End If

	End If

	' 2010-02-02 Date:がないメールだとINSERTでこける
	If IsEmpty(fieldDate) Then
		fieldDate = rcvDate
	End If

	IF folName = "_results" Then
		Exit Function
	End If
	Set cn = CreateObject("ADODB.Connection")
	cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
						 "Data Source=coldspa.mdb;"
	sql = "SELECT count(*) FROM mail WHERE folder = '" & folName _
	& "' AND id='" & id_ & "';"
	Set rs = cn.Execute(sql)
	If rs.Fields(0).Value > 0 Then
		' 登録済みなら何もしない
		cn.Close
		Exit Function
	End If

	flds = dat.Keys
	For i = 0 To dat.Count -1
		d = Split(flds(i), ":", 2)	'行番とフィールド名を分離
		sql = "INSERT INTO mail (id, partNo, fieldName, fieldDate, parentId, receiveDate, folder, content) " _
			& " VALUES (" _
			& "'" & id_ & "', " _
			& "'" & d(0) & "', " _
			& "'" & d(1) & "', " _
			& "'" & fieldDate & "', " _
			& "'" & parent_ & "', " _
			& "'" & rcvDate & "', " _
			& "'" & folName & "', " _
			& "'" & Replace(dat(flds(i)), "'", "''") & "'" _
			& ");"
		cn.Execute sql
	Next

'	Do While Not rs.EOF And Not rs.BOF
'		rs.MoveNext
'	Loop
	cn.Close
End Function


' ************************************************
' 公開メソッド
' ************************************************
' ************************************************
' file(ｘｍｌ)をxpathで選択した結果をtextで返す
' ************************************************
Function selectXML(xpath, file)
	' xpathにマッチする複数ノードから
	' それぞれひとつのテキストを得るのに適している
	' 複数ノードにマッチする場合、結果は改行で区切られる（1行／ノード）
  Dim dom
  Set dom = CreateObject("MSXML2.DOMDocument")
  dom.validateOnParse = True
  dom.async = False
  dom.resolveExternals = True
  dom.preserveWhiteSpace = True
  dom.load file
  If (dom.parseError.errorCode <> 0) Then
      Call dspParseErr(dom.parseError,False)
      Set dom = Nothing
      Exit Function
  End If
  dom.setProperty "SelectionLanguage", "XPath"

  Dim n, m, p, res
  Set n = dom.selectNodes(xpath)

  For Each m In n
    p = jReplace(m.text, "\r?\n", vbCrLf)
    res = res & p & vbCrLf
  Next
  Set dom = Nothing
	selectXML = res
End Function

' ************************************************
' ************************************************
' file(ｘｍｌ)をxpathで選択した結果をtextで返す（singleNode版）
' ************************************************
Function selectXMLs(xpath, file)
	' xpathにはタブで区切って複数のxpath式を書く
	' 各xpathにマッチするひとつのノード（複数あっても先頭だけ）から
	' 複数の値テキストを得るのに適している
	' 結果はタブで区切られる。最後に改行は付かない
  Dim dom
  Set dom = CreateObject("MSXML2.DOMDocument")
  dom.validateOnParse = True
  dom.async = False
  dom.resolveExternals = True
  dom.preserveWhiteSpace = True
  dom.load file
  If (dom.parseError.errorCode <> 0) Then
      Call dspParseErr(dom.parseError,False)
      Set dom = Nothing
      Exit Function
  End If
  dom.setProperty "SelectionLanguage", "XPath"

  Dim n, x, i, p, res
	x = Split(xpath, vbTab)

  For i = LBound(x) To UBound(x)
  	Set n = dom.selectSingleNode(x(i))
		If Not n Is Nothing Then
    	p = jReplace(n.text, "\r?\n", vbCrLf)
			res = res & p & vbTab
		End If
  Next
  Set dom = Nothing
	
	res = jReplace(res, "\t$", "")
	selectXMLs = res
End Function

' ************************************************
' file(ｘｍｌ)をDomDocumentにloadしてそのオブジェクトを返す
' ************************************************
Function loadXML(file)
  Dim dom
  Set dom = CreateObject("MSXML2.DOMDocument")
  dom.validateOnParse = True
  dom.async = False
  dom.resolveExternals = True
  dom.preserveWhiteSpace = True
  dom.load file
  If (dom.parseError.errorCode <> 0) Then
      Call dspParseErr(dom.parseError,False)
      Set dom = Nothing
      Exit Function
  End If
  dom.setProperty "SelectionLanguage", "XPath"

	Set loadXML = dom
End Function

' ************************************************
Function makeAccountList()
  Dim settings
  Set settings = CreateObject("MSXML2.DOMDocument")
  settings.validateOnParse = True
  settings.async = False
  settings.resolveExternals = True
  settings.preserveWhiteSpace = True
  settings.load "spa.xml"
  If (settings.parseError.errorCode <> 0) Then
      Call dspParseErr(settings.parseError,False)
      Set settings = Nothing
      Exit Function
  End If
  settings.setProperty "SelectionLanguage", "XPath"

  Dim ads, ad, addr, ret
  Set ads = settings.selectNodes("/spa/filter-definition/accounts/account-def")
  For Each ad In ads
    addr = ad.getAttribute("addr")
    If Not IsNull(addr) Then
      If InStr(1, addr, "@") = 1 Then
        addr = ad.getAttribute("user") & addr
      End If
      ret = ret & ad.getAttribute("id") & " <" & addr & ">" & vbCrLf
    End If
  Next
  makeAccountList = ret
  Set settings = Nothing
End Function

' ************************************************
Function isNWAvailable()
'
' 2008-02-15 利用可能なネットワークがあれば1を返す
'
' for winXP
'    'Const cplNW = "ネットワークとダイヤルアップ接続"
'    Const cplNW = "ネットワーク接続"
'    Dim i, fol, fitem
'    ' コントロールパネル（３）取得
'    Set fitem = lookup_(cplNW, _
'                         shapp.NameSpace(3).Items)
'
'    Set fol = fitem.GetFolder
'    For Each i In fol.items
''      WScript.Echo i.Name
''      WScript.Echo vbTab & fol.GetDetailsOf(i, 1) '種類欄
''      WScript.Echo vbTab & vbTab & fol.GetDetailsOf(i, 2) '状態欄
'      If i.Name <> "1394 接続" Then '1394は無視
'        If fol.GetDetailsOf(i, 2) = "接続" Then
'					isNWAvailable = 1
'          Exit Function
'        End If
'      End If
'    Next

' for winVista and later
		Dim strComputer, objWMIService, colItems, objItem
		strComputer = "." 
		Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\CIMV2") 
		Set colItems = objWMIService.ExecQuery("SELECT * FROM Win32_NetworkAdapter WHERE AdapterTypeId=0 AND NetConnectionStatus=2")

		For Each objItem in colItems 
			'Wscript.Echo "Name: " & objItem.Name
			'Wscript.Echo "Description: " & objItem.Description
			'Wscript.Echo "AdapterTypeId: " & objItem.AdapterTypeId
			'Wscript.Echo "NetConnectionStatus: " & objItem.NetConnectionStatus
			isNWAvailable = 1
			Exit Function
		Next

    '接続中ネットワークなし
		isNWAvailable = 0
End Function

' ************************************************
Function isJustAwoke()
' スリープから復帰したばかり（1分以内）なら1を返す
' 復帰時はahkのtimerがすぐ動くが、N/W が立ち上がっていなくて
' エラーになるのがワズイ
	Dim wmi, fromDate, events, e
	Set wmi = GetObject("winmgmts:\\localhost\root\cimv2")
	' 条件と結果をlocaltime で
	Set fromDate = CreateObject("WbemScripting.SWbemDateTime")
	' 一分以内
	fromDate.SetVarDate DateAdd("n", -1 , Now), True

	'1分以内にスリープから再開したイベントログがあるかどうかの
	' クエリーWQL
	Set events = wmi.ExecQuery( _
	"Select * From Win32_NTLogEvent Where Logfile='System' And TimeGenerated >= '" & fromDate & "' And SourceName ='Microsoft-Windows-Power-Troubleshooter'")
	isJustAwoke = (events.Count > 0)
End Function

' ************************************************
Sub extractMail(id, parent, folName, mime)
  'メールヘッダ部、本文と添付ファイルを規定フォルダへ抽出
  Dim tmpd, h, dest, ots, i
  tmpd = getTmpDir()
  If Not fso.FolderExists(tmpd) Then
    fso.CreateFolder(tmpd)
  End If

	' 2009-11-30 LVイベントによってはLog、_resultsでfileが渡される
	If InStr(1, id, "\#Log\") > 0 Or InStr(1, id, "\_results\") > 0 Then
		Exit Sub
	End If

'Stop
  dest = basp.Match("/.*\\(.*)$/ik", id) ' get uidx
  If InStr(1, dest, "rfc822") Then
    '受信添付メール
    dest = tmpd & "\" & basp.MD5(id, 1) ' 添付メールネスト対策
  Else
		If InStr(1, mime, "rfc822") Then
			dest = tmpd & "\" & basp.MD5(id, 1) ' 添付メールネスト対策
		Else
			'草稿添付メール
			dest = tmpd & "\" & dest
		End If
  End If
'Stop
  If fso.FileExists(dest) Then
    fso.DeleteFile dest, True
  End If
  If Not fso.FolderExists(dest) Then
    fso.CreateFolder(dest)
  End If

  ' 2007-09-26 ２重呼び出し時、書き込みできませんエラー避け
  If fso.FileExists(dest & "\header.txt") Then
    Exit Sub
  End If

  ' 2009-06-09 展開メールフォルダをグローバルに
  extractDir = dest

' 2008-03-20 senderで転送時に元ファイルを直接filesに指定するようにした
'            コピーされないときがあるので
'   ' 2007-06-14 ファイルそのままも作業フォルダへコピー（転送用）
'   On Error Resume Next
'   fso.CopyFile id, dest & "\" , True
' 'Stop
'   If Err.Number <> 0 Then
'   'If Err.Number <> 70 Then
'     i = Err.Number
'     h = Err.Description
'     On Error Goto 0
'     Err.Raise i, "cold spa", h
'   'End If
'   End If
'   On Error Goto 0

	' 2012-03-30 メールファイル消失or破壊されていてもDBにあれば復元
	If retrievalFromDB(id, dest) Then
		' 復元した
		Exit Sub
	End If

  'ヘッダ(Subject, From, To, Cc)がUTF-8MIME+B またはQなら自力でデコードする
  Dim utf8mimeHeaders
  Set utf8mimeHeaders = utf8headerDecode(id)

  Dim buf, contentTypeVal, contentTransEncVal, dat, s, fieldDate
  Set dat = CreateObject("Scripting.Dictionary")	'インデックス登録へ渡すデータ

  h = basp.ReadMail(id, "", ">" & dest)


  If IsArray(h) Then
    Set ots = fso.OpenTextFile(dest & "\header.txt", 2, True)
    For i = 0 To UBound(h)
      If InStr(1, h(i), "Body:") = 1 Then
        ots.Close
        buf = determinedBody(contentTypeVal, contentTransEncVal, h(i), id)
        Set ots = fso.OpenTextFile(dest & "\body.txt", 2, True)
'Stop
        ots.Write buf
        ots.Close
				dat.Add i & ":Body", buf
        Set ots = fso.OpenTextFile(dest & "\files.txt", 2, True)
      Else
        Dim hname
        hname = basp.Match("/^(From|To|Cc|Subject):\s+.*/ik", h(i))
'Stop
        If hname <> "0" _
        And utf8mimeHeaders.Exists(hname) Then
          '自力デコードヘッダがあれば
          ots.WriteLine hname & ": " & utf8mimeHeaders(hname)
					dat.add i & ":" & hname, utf8mimeHeaders(hname)
        Else
          ots.WriteLine h(i)
        	s = Split(h(i), ":", 2)	'フィールド名と値を分離
					dat.Add i & ":" & s(0), Trim(s(1))
					If basp.Match("/^date$/i", s(0)) <> "0" Then
						fieldDate = s(1)
					End If
        End If
'Stop
        buf = basp.Match("/^Content-Type:\s+(.*)$/ik", h(i))
        If buf <> "0" Then
          contentTypeVal = buf
        Else
          buf = basp.Match("/^Content-Transfer-Encoding:\s+(.*)$/ik", h(i))
          If buf <> "0" Then
            contentTransEncVal = buf
          End If
        End If
      End If
    Next
    ots.Close

    ' 隠し属性にして
		If False Then
		' v3 では隠しにしない
    Set i = fso.GetFile(dest & "\header.txt")
    i.attributes = i.attributes + 2
    Set i = fso.GetFile(dest & "\body.txt")
    i.attributes = i.attributes + 2
    Set i = fso.GetFile(dest & "\files.txt")
    i.attributes = i.attributes + 2
		End If

    ' 2008-03-20 もう転送用コピーは廃止した
    'Set i = fso.GetFile(dest & "\" & fso.GetFile(id).Name)
    'i.attributes = i.attributes + 2
  Else
    MsgBox id & ": " & h, vbExclamation, "coldspa"
  End If
'Stop
	If InStr(1, folName, "#") <> 1 And folName <> "" Then
		Call registIdx(id, parent, folName, fieldDate, dat)
	End If
End Sub

' ************************************************
Function vbs(script)
	'引数文字をｖｂｓとして実行する。
	'戻り値を得る場合は引数の最後で「vbs=値」で代入する
	Execute (script)
End Function

Function gvbs(script)
	'引数文字をｖｂｓとしてGlobal空間で実行する。
	'vbsと異なる点は、script内の Sub, Function から
	'（同じscript内で定義された）別のSub, Function
	'を呼び出すことができる
	'戻り値を得る場合は引数の最後で「gvbs=値」で代入する
	ExecuteGlobal (script)
End Function

Function vbsAsync(script)
	'引数文字をｖｂｓとして別プロセスで非同期実行する。
	'vbsファイル名を返す
	Dim file, ts, small
	Set small = CreateObject("SmallLib.SmallObject")	' 2014-02-22
	file = small.MD5(script) & ".vbs"
	Set small = Nothing
	Set ts = fso.OpenTextFile(file, 2, True)
	ts.Write script
	ts.Close
	' wow64
	Call sh.Run("c:\windows\syswow64\wscript.exe " & file, 7, False)
	vbsAsync = file
End Function

' ************************************************
Sub searchIdx(fol, kwstr, workdir, d1, d2)
  'メールの検索(indexを)
    progressLog "Searching..."

    Dim i, j, hit, k, list, m, listpath, folname, resultsdom, h, hc
    'フォルダ定義をDOMに
    Set def = CreateObject("MSXML2.DOMDocument")
    def.load "folders.xml"
    def.setProperty "SelectionLanguage", "XPath"

    '結果一覧出力DOM
    Set resultsdom = CreateObject("MSXML2.DOMDocument")
    Set n = resultsdom.createProcessingInstruction( _
                "xml", "version=""1.0"" encoding=""Shift_JIS""")
    resultsdom.appendChild n
    resultsdom.appendChild resultsdom.createElement("mails")
    resultsdom.documentElement.appendChild resultsdom.createTextNode(vbCrLf)
    resultsdom.setProperty "SelectionLanguage", "XPath"


    If fol = "" Then
      ' 2007-06-27 全フォルダ検索
      Set folders = def.selectNodes("//folder")

    Else
			fol = Replace(fol, ":", "")
      ' 2007-06-27 1フォルダのみ検索
      Dim target, n
      ' 2009-06-30 アーカイブの検索はできない
        ' 通常フォルダの検索
        target = fol
        If target = "_results" Then
          ' FIXME: 検索結果をさらに検索する場合
          Set n = def.documentElement.appendChild(def.createElement("folder"))
          n.setAttribute "name", "_results"
        End If

      Set folders = def.selectNodes("//folder[@name='" _
              & target & "']")
    End If

    If target <> "_results" Then
      '結果フォルダの初期化
      'FIXME: 初期化してもしなくても検索結果再検索できない
      Dim results, path, def, folders, folder, files, file
      results = workdir & "\_results"
      With fso
        If .FolderExists(results) Then
          Call .DeleteFolder(results, True)
        End If
        .CreateFolder results
      End With
    End If

		' キーワードを配列にする
		dim keywords, fldval
		keywords = Split(kwstr, " ")

		' 2010-02-02 日付の範囲指定
		Dim date_spec
		If d1 <> "" AND d2 <> "" Then
			If CDate(d1) > CDate(d2) Then
				date_spec = " AND fieldDate BETWEEN CDate('" & d2 & "') AND CDate('" & d1 & "')"
			Else
				date_spec = " AND fieldDate BETWEEN CDate('" & d1 & "') AND CDate('" & d2 & "')"
			End If
		Else
			date_spec = ""
		End If

		'インデックスに接続
		Dim cn, sql, rs
		Set cn = CreateObject("ADODB.Connection")
		cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
						 "Data Source=coldspa.mdb;"
    With fso
    For Each folder In Folders
      'フォルダ毎（#Listはインデックスは作成されないので不可能）
      folname = folder.getAttribute("name")
			' 2010-03-07 listfile場所換え
			path = workdir & "\" & folname
			listpath = workdir & "\" & folname & ".xml"

			'リストxmlをDOMに
      Set list = CreateObject("MSXML2.DOMDocument")
    	list.setProperty "SelectionLanguage", "XPath"
      list.load listpath

      ' フォルダごとの件数数え
      k = 0
			sql ="SELECT count(*) FROM" _
			& " (SELECT distinct id  FROM mail WHERE folder='" & folname & "'" _
				& date_spec & ");"
			Set rs = cn.Execute(sql)
			m = rs.Fields(0).Value 
      progressLog folname & ": Searching(" & m & ")..."

			Set hit = New searchResults
			hit.init(cn)
			For j = 0 To UBound(keywords)
				'キーワード毎

				'フィールド名とパターンを分離して登録
				fldval = Split(keywords(j), ":", 2)
				If UBound(fldval) = 0 Then
					' 2009-07-18 フィールド名の指定がなければbodyにする
					ReDim Preserve fldval(1)
					fldval(0) = "body"
					fldval(1) = keywords(j)
				End If
				hit.registField fldval(0)

				' 2007-07-07 アイコン検索
				Dim ico, nn
				If basp.Match("/icon/ik", fldval(0)) <> "0" Then
					ico =  fldval(1)
					If CInt(ico) > 0 Then
						' icon: キーワード指定された
						Set n = list.selectNodes("/mails/mail[icon/text()='" & ico & "']")

						For Each nn In n
							'idとフィールド名を登録
							hit.entry nn.getAttribute("id"), fldval(0), nn.selectSingleNode("./date/text()").nodeValue
						Next
					End If
				Else

					'当該フィールドのみ抽出
					sql = "SELECT id, content, fieldDate FROM mail" _
					& " WHERE folder='" & folname & "'" _
					& " AND fieldName='" & fldval(0) & "'" _
					& date_spec & ";"
					' & " AND id " & hit.whereIDstr() & ";"
					Set rs = cn.Execute(sql)
					Do While Not rs.BOF And  Not rs.EOF
						If basp.Match("/" & fldval(1) & "/ik", rs("content").Value) <> "0" Then
							'idとフィールド名を登録
							hit.entry rs("id").Value, fldval(0), rs("fieldDate").Value
						End If
						rs.MoveNext
					Loop
				End If

			Next  '次のキーワード

			sql = "SELECT t0.id FROM " _
			& hit.fromStmt & " WHERE " & hit.whereStmt & " ORDER BY t0.fieldDate desc;"
'Stop
			Set rs = cn.Execute(sql)

      k = 0
			Do While Not rs.BOF And  Not rs.EOF

				'結果リストへ登録
				Set n = list.selectSingleNode( _
						"/mails/mail[@id='" & rs("id").Value &  "']")
				If n Is Nothing Then
					put_Clipboard rs("id").Value
    			MsgBox rs("id").Value & ": no longer exists" & vbCrLf _
					& "(clipboard copied)" _
					, vbExclamation, "coldspa"
				Else
				Set n = resultsdom.documentElement.appendChild(n.cloneNode(True))
				' 2008-03-02 パスを結果へタグ出力(結果からのMove toメニューで参照する)
				Set n = n.appendChild(resultsdom.createElement("path"))
				n.text = path

				resultsdom.documentElement.appendChild resultsdom.createTextNode(vbCrLf)
				End If

				rs.MoveNext

				' プログレスバーの更新
				k=k+1
				progressLog folname & ": " & k & "/" & m & " Processed."
			Loop

      Set list = Nothing
    Next
    End With

    ' 一応いっぱいにして終わった感出す
    progressLog folname & ": " & m & "/" & m & " Processed."

    Set def = Nothing
    resultsdom.save workdir & "\_results.xml"
    Set resultsdom = Nothing
		cn.Close

    progressLog "Process done."
End Sub

' ************************************************
Sub discardIdx(fol, workdir)
	' 2009-07-01 インデックスにあって実ファイルがないものをインデックスから消す
		'インデックスに接続
		Dim cn, sql, rs, i, m
		Set cn = CreateObject("ADODB.Connection")
		cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
						 "Data Source=coldspa.mdb;"
		' id件数
		sql = "SELECT COUNT(id) FROM (SELECT DISTINCT id FROM mail WHERE folder = '" & fol & "');"
		Set rs = cn.Execute(sql)
		m = rs.Fields(0).Value 

'Stop
		' id列挙
		sql = "SELECT DISTINCT id FROM mail WHERE folder = '" & fol & "';"
		Set rs = cn.Execute(sql)

		i = 0
		Do While Not rs.BOF And  Not rs.EOF
			If Not fso.FileExists(workdir & "\" & fol & "\" & rs("id").Value) Then
				cn.Execute "DELETE FROM mail WHERE folder = '" & fol _
				& "' AND id = '" & rs("id").Value & "';"
			End If
			rs.MoveNext
			i = i+1
			progressLog "discard: " & i & "/" & m
		Loop
		cn.Close
End Sub

' ************************************************
Function baspW3getEx(url, outfile, intype, outtype)
	' baspのW3get拡張
	' intype [in]  : 元の漢字コードのタイプを指定します。
	' outtype [in]  : 変換後の漢字コードのタイプを指定します。
	' 	W3getの -j で指定する charset:
	'		none：変換しない（intype, outtype の何れかがnoneなら-jしない）
	'		sjis : SJIS	(kconvでは1)
	'		euc  : EUC	(以下同2)
	'		jis  : JIS	(3)
	'		ucs2 : UNICODE UCS-2	(4)
	'		utf8 : UNICODE UTF-8	(5)
	'   ※intype が utf8 の場合-jで失敗する場合があるので
	'     自力で（kconvを呼んで）intypeを明示し変換
	'		  （-j指定時は内部でintype省略（自動判別）のkconvしていると思われる）
	' 200 以外の以下のレスポンスだった場合フォローする
	' 	301 Moved Permanently
	' 	302 Found
	' 正常時は1を返す（w3getと同様にDLファイル数として）

	Dim param, temp, d, f, t, kconv_outtype

	temp = sh.ExpandEnvironmentStrings("%TEMP%") & "\"
	t = fso.GetTempName
	f = fso.GetBaseName(outfile) & "." & fso.GetExtensionName(outfile)
	d = fso.GetParentFolderName(outfile) & "\"
	If Not fso.FolderExists(d) Then
		Err.Raise 1, "cold spa", "outfolder " &  d  & " is not exists."
	End If

	param = "-l " & temp & "w3get.log -d " & temp _
		& " -o " & t & " "
	' 2010-01-05 NOTE: -d でdlFolderを直接指定するとW3getがエラーになるので
	' DL後移動する（パスに日本語があるとNG？）
	' utf8バグのため-jが必要か自分で判断
	If intype <> "utf8" Then
		If intype <> "none" And outtype <> "none" Then
			param = param & "-j " & outtype & " "
		End If
	Else
		' intypeがutf8
		If outtype <> "utf8" And outtype <> "none" Then	'同じなら-jする必要がないので
			Select Case outtype
			Case "sjis"
				kconv_outtype = 1
			Case "euc"
				kconv_outtype = 2
			Case "jis"
				kconv_outtype = 3
			Case "ucs2"
				kconv_outtype = 4
			End Select
			'要コード変換
		Else
			kconv_outtype = 0
		End If
	End If

	baspW3getEx = doW3get_(param & url, temp, t, d, f, intype, kconv_outtype)
	If baspW3getEx <> 1 Then	'{
		' エラー内容を調べる
		Dim errbuf, moved, ts
		Set ts = fso.OpenTextFile(temp & "w3get.log", 1, False)
		Do While ts.AtEndOfStream <> True	'{

			errbuf =ts.ReadLine
			moved = basp.Match("/end\s-30[12]\s(http.+)/", errbuf)
			If moved <> "0" Then '{
				' 301 Moved Permanently
				' 302 Found

				' 再ダウンロード
				baspW3getEx = doW3get_(param & moved, temp, t, d, f, intype, kconv_outtype) 
				Exit Do
			End If	'}
		Loop '}
		ts.Close

	End If	'}
End Function

Function doW3get_(arg, temp, t, d, f, intype, kconv_outtype)
	' w3getして必要ならコード変換
	Dim res
	res = basp.W3get(arg)
	If res = 1 Then
		If intype = "utf8" And kconv_outtype <> 5 And kconv_outtype <> 0 Then
			'要コード変換
			res = basp.KconvFile(temp & t, d & f, kconv_outtype, 5)
			If res < 0 Then
				Err.Raise("kconvfile faild(" & res & ").")
				res = 0
			End If
			On Error Resume Next
			fso.DeleteFile temp & t, True
			On Error Goto 0
		Else
			'移動
			On Error Resume Next
			fso.DeleteFile d & f, True
			On Error Goto 0
			fso.MoveFile temp & t, d & f	' FIXME: ahkソースで実行させるとココでエラーに
		End If
	
		doW3get_ = res
	Else
		doW3get_ = res
	End If
End Function

' ************************************************
Function setWorkInProgress( type_, id, listfile, workdir)
	' 保留設定・解除し、保留件数を返す
	' type_ : 0:解除, 1:設定, 
	' 				2:件数を返すのみ（id指定されていればそのメールのみ
	'														保留中かどうかわかる）
  Dim list, wip
	' WIP登録のDOM
	Set wip = CreateObject("MSXML2.DOMDocument")
	wip.validateOnParse = True
	wip.async = False
	wip.resolveExternals = True
	wip.preserveWhiteSpace = True
	If Not fso.FileExists(workdir & "\" & "#WIP.xml") Then
    Set n = wip.createProcessingInstruction( _
                "xml", "version=""1.0"" encoding=""Shift_JIS""")
    wip.appendChild n
    wip.appendChild wip.createElement("mails")
    wip.documentElement.appendChild wip.createTextNode(vbCrLf)
	Else
  	wip.load workdir & "\" & "#WIP.xml"
	End If
	wip.setProperty "SelectionLanguage", "XPath"

	Set n = wip.documentElement.selectSingleNode(_
        "/mails/mail[@id='" & id & "']")

	Dim n, m
	If type_ = 2 Then
		If id <> "" Then
			'そのメールが登録中かどうかを返す
			If n Is Nothing Then
				setWorkInProgress = 0
			Else
				setWorkInProgress = 1
			End If
		Else
			' 全件数を返す
			setWorkInProgress = wip.selectNodes("/mails/mail").length
		End If
		Exit Function
	End If

	If Not n Is Nothing Then
		' 既に登録されている場合は削除する
		' 改行textも削除
		Set m = n.previousSibling
		If Not m Is Nothing Then
			If m.nodeType = 3 Then	' NODE_TEXT (3)
				n.parentNode.removeChild m
			End If
		End If
			
    n.parentNode.removeChild n
		' 保留解除ならこのままsave
	End If

	If type_ = 1 Then	'保留登録
		' 対象メールのDOM
		Set list = CreateObject("MSXML2.DOMDocument")
		list.validateOnParse = True
		list.async = False
		list.resolveExternals = True
		list.preserveWhiteSpace = True
		list.load listfile
		If (list.parseError.errorCode <> 0) Then
				Call dspParseErr(list.parseError,False)
				Set list = Nothing
				Exit Function
		End If

		list.setProperty "SelectionLanguage", "XPath"
		' 登録元複製して登録先へ
		Set n = list.documentElement.selectSingleNode(_
					"/mails/mail[@id='" & id & "']").cloneNode(True)
		Set m = wip.createElement("path")
		m.text = workdir & "\" & fso.GetBaseName(listfile)
		n.appendChild m
		wip.documentElement.appendChild n
		wip.documentElement.appendChild wip.createTextNode(vbCrLf)
	End If

	setWorkInProgress = wip.selectNodes("/mails/mail").length
	wip.save workdir & "\" & "#WIP.xml"

  Set list = Nothing
  Set wip = Nothing
End Function

' ************************************************
Function utf8headerDecode(file)
  ' target: From To Cc Subject
  Dim ts, buf, fieldName, value, s, ret
  fieldName = ""
  value = ""
  Set ret = CreateObject("Scripting.Dictionary")

	On Error Resume Next
  Set ts = fso.OpenTextFile(file, 1, False)
	If Err.Number <> 0 Then
		s = Err.Number
		ret = Err.Description
    On Error Goto 0
    Err.Raise s, "cold spa", file & ": " & ret
	End If

  Do While ts.AtEndOfStream <> True
    buf = ts.ReadLine
    If buf = "" Then
      Exit Do
    End If
    s = basp.MatchEx("/^(From|To|Cc|Subject):\s+(.*)$/ik", buf)
    If IsArray(s) Then
        If fieldName <> "" Then
          If doMimeDecode(value) Then
            ret.Add fieldName, value
          End If
          fieldName = ""
          value = ""
        End If
      fieldName = s(3)
      value = s(4)
    Else
			' 2012-10-22 その他のヘッダかどうかを検査しそうであれば
			' fieldName と value をリセットする
      s = basp.MatchEx("/^([\w\x2d]+):\s+(.*)$/ik", buf)
      If IsArray(s) Then
        If fieldName <> "" Then
          If doMimeDecode(value) Then
            ret.Add fieldName, value
          End If
          fieldName = ""
          value = ""
        End If
      Else
				' 2012-10-22 新たなヘッダの始まりでない場合は直近のfieldNameの続き
				' valueに連結
        value = value & buf
      End If
    End If

  Loop
  ts.Close
  Set utf8headerDecode = ret
End Function

' ************************************************
Function myBase64Decode(sFile, dFile)
	' 2012-11-21 baspのはオカシイ
	Const adTypeBinary=1 
	Const adSaveCreateNotExist=1
	Const adSaveCreateOverWrite=2
	Dim Dom
	Dim Tmp 
	Dim Bin 
	Dim Dst

	Set Dom=CreateObject("Microsoft.XMLDOM") 
	Set Tmp=Dom.createElement("tmp") 
	Tmp.DataType="bin.base64" 
	Tmp.Text=fso.OpenTextFile(sFile).ReadAll()
	Bin=Tmp.NodeTypedValue 

	If fso.FileExists(dFile) Then
		fso.DeleteFile dFile, true
	End If

	Set Dst=CreateObject("ADODB.Stream") 
	Dst.Open 
	Dst.Type=adTypeBinary 
	Dst.Write Bin 
	Dst.SaveToFile dFile,adSaveCreateNotExist
	Dst.Close 

End Function

' ************************************************
' selectXML2JSON 内部用(非公開)
	Function evalNode_(n, isArrayElement)
		Dim beginContent, endContent, lineBreak, ret
		'lineBreak = vbCrLf
		lineBreak = ""
		beginContent = "{"
		endContent = "},"
		ret = ""

		If isArrayElement Then
			' 要素が配列表現の場合：
			' 名は上位で出力済みのためこのレベルでは出力しない
			ret = beginContent & lineBreak

			If n.nodeName = "#text" Or n.nodeTypeString = "attribute" Then
				' 自分がテキストなら
				' 属性なら（xpathで属性を直接selectしたとき
				' 値のみ出力
				ret = "'" & json_enc_(n.nodeValue) & "'," & lineBreak
			End If
		Else
			If n.nodeName = "#text" Or n.nodeTypeString = "attribute" Then
				' 自分がテキストなら
				' 属性なら（xpathで属性を直接selectしたとき
				' 内容括りなしで名前＆値を出力
				ret = "'" & n.nodeName & "': '" & json_enc_(n.nodeValue) & "'," & lineBreak
			Else
				' 要素
				ret = "'" & n.nodeName & "': " & beginContent & lineBreak
			End If
		End If

		Dim a
'WScript.Echo n.nodename & ": " & typeName(n.Attributes)
		If Not n.Attributes Is Nothing Then
			For Each a In n.Attributes
				ret = ret & "'" & a.nodeName & "':'" & json_enc_(a.nodeValue) & "'," & lineBreak
'WScript.Echo ret
'WScript.Echo a.nodeName & "(attr): " & typeName(a) & ": " & a.nodeTypeString
'WScript.Quit(0)
			Next
		End If

		' 子に同名要素があるかどうか調べる
		Dim dic, k, m, p
    Set dic = CreateObject("Scripting.Dictionary")
		If n.hasChildNodes Then
			For Each a In n.childNodes
				If Not dic.Exists(a.nodeName) Then
					dic.Add a.nodeName, 1
				Else
					dic(n.nodeName) = dic(n.nodeName) + 1 
				End If
			Next
		End If

		' 各要素に対して一種類ずつ（同名要素は配列で括る）
		For Each k In dic.Keys
			Dim nname
			If k = "#text" Then
				nname = "text()"
			Else
				nname = k
			End If
			Set m = n.selectNodes("./" & nname)
			For Each p In m
				If dic(k) > 1 Then
					' 配列括り
					ret = ret & "'" & p.nodeName & "':'[" & lineBreak
				End If

				ret = ret & evalNode_(p, (dic(k) > 1))

				If dic(k) > 1 Then
					' 配列括り
					ret = ret & "]," & lineBreak
				End If
			Next
		Next

		If isArrayElement Then
			' 最後のカンマは上位でトル
			If n.nodeName = "#text" Or n.nodeTypeString = "attribute" Then
				' 内容括り閉じなしで出力
			Else
				ret = ret & endContent & LineBreak
			End If
		Else
			If n.nodeName = "#text" Or n.nodeTypeString = "attribute" Then
				' 自分がテキストまたは
				' 属性なら（xpathで属性を直接selectしたとき
				' 内容括り閉じなしで出力
				' 最後のカンマトル
				ret = jReplace(ret, ",(\r?\n)?$", "") & LineBreak
			Else
				ret = jReplace(ret, ",(\r?\n)?$", LineBreak) & endContent & LineBreak
			End If
		End If

		evalNode_ = ret
	End Function
' ************************************************

Function selectXML2JSON(xpath, file)
	' xpath結果をjson文字列で返す
	' 2013-07-26 最上位ノードは必ず配列になる
	' 当初単一の場合はスカラにしていたがahk側でlengthが参照できなくなり判定が必要になるためヤメた
	' ahk側では常にlengthを参照してループする
	Dim LineBreak
	'lineBreak = vbCrLf
	lineBreak = ""
  Dim dom
  Set dom = CreateObject("MSXML2.DOMDocument")
  dom.validateOnParse = True
  dom.async = False
  dom.resolveExternals = True
  'dom.preserveWhiteSpace = True
  dom.load file
  If (dom.parseError.errorCode <> 0) Then
      Call dspParseErr(dom.parseError,False)
      Set dom = Nothing
      Exit Function
  End If
  dom.setProperty "SelectionLanguage", "XPath"

  Dim n, m, p, ret
  Set n = dom.selectNodes(xpath)
	'WScript.Echo typename(n) & ": start: " & n.length
	ret = "{"

	' 最上位ノードの配列開き
	ret = ret & "'" & n(0).nodeName & "':[" & LineBreak

	If n.length > 0 Then
		For Each m In n
			ret = ret & evalNode_(m, True)
		Next
	End If

	'WScript.Echo typename(n) & ": finish: " & n.length
	' 最上位ノードの配列閉じ
	ret = jReplace(ret, ",(\r?\n)?$", LineBreak) & "]" & LineBreak

	ret = jReplace(ret, ",(\r?\n)?$", LineBreak) & "}" & LineBreak

	' おかしいカンマを適当にトル
	ret = Replace(ret, ",}", "}")

	selectXML2JSON = ret
End Function
' ************************************************

]]>
</script>
<script language="JScript">
<![CDATA[
// ************************************************
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


//
// wget object {
//
function wget(method, url, postdata, headers)
{

	if(method == "NOP"){ return; }

	//this.xmlhttp = new ActiveXObject("MSXML2.XMLHTTP");
	this.xmlhttp = new ActiveXObject("Msxml2.ServerXMLHTTP.3.0");

	var lResolve = 5 * 1000;
	var lConnect = 5 * 1000;
	var lSend = 15 * 1000;
	var lReceive = 15 * 1000;
	this.xmlhttp.setTimeouts(lResolve, lConnect, lSend, lReceive);
	
	this.xmlhttp.open(method, url, true);
	for(var k in headers){
		this.xmlhttp.setRequestHeader(k, headers[k]);
	}
	this.xmlhttp.send(postdata);

	while(this.xmlhttp.readyState != 4){
		//WScript.Sleep(250);
		this.xmlhttp.waitForResponse(250);
	}
	this.status = this.xmlhttp.status;
	this.statusText = this.xmlhttp.status + " " + this.xmlhttp.statusText;
}
wget.prototype.save = function (path, isHeaderSave) {
	var	s = new ActiveXObject("ADODB.Stream");
	s.Type = 1;   // adTypeBinary
	s.Open();
	if(isHeaderSave){
		//var b = basp.ByteArray(this.xmlhttp.getAllResponseHeaders());
		// 2013-07-22
		var b = this.str2byteArray(this.xmlhttp.getAllResponseHeaders());
		s.Write(b);
	}
	s.Write(this.xmlhttp.responseBody);
	s.Position = 0;  // rewind
	/*
	if(fso.FileExists(path)){
		fso.DeleteFile(path, true);
	}
	s.SaveToFile(path, 1);
	*/
	s.SaveToFile(path, 2);
	s.Close();
/*
	var ts = fso.OpenTextFile(path, 2, true);
	var s = "";
	if(isHeaderSave){
		s = this.xmlhttp.getAllResponseHeaders();
	}
	s += this.xmlhttp.responseText;
	ts.Write(s);
	ts.Close();
*/
}
wget.prototype.saveAsText = function (path, encoding) {
	var	s = new ActiveXObject("ADODB.Stream");
	s.Type = 1;   // adTypeBinary = 1
	s.Open();
	s.Write(this.xmlhttp.responseBody);
	s.Position = 0;  // rewind

	s.Type = 2;   // adTypeText = 2
  s.Charset = encoding; // euc-jp utf-8 unicode iso-2022-jp shift_jis
	var buf = s.ReadText(-1); // adReadAll = -1
	s.Close();

	var d = new ActiveXObject("ADODB.Stream");
	d.Type = 2;   // adTypeText = 2
	d.Open();
  d.Charset = "shift_jis"; // euc-jp utf-8 unicode iso-2022-jp shift_jis
	d.WriteText(buf);
	d.SaveToFile(path, 2); // adSaveCreateNotExist = 1, adSaveCreateOverWrite = 2
	d.Close();

	return;
}
wget.prototype.getRespText = function () {

	
	var ret = this.xmlhttp.responseText;

	/*
	var adTypeText = 2, adTypeBinary = 1;
	var adSaveCreateOverWrite = 2, adSaveCreateNotExist = 1;
	var adReadAll = -1;
	var adReadLine = -2;
	var	s = new ActiveXObject("ADODB.Stream");
  s.Type = adTypeBinary;
	s.Open();
	s.Write(this.xmlhttp.responseText);
	s.Position = 0;  // rewind
  s.Charset = respEncode; // "UTF-8";
	var ret = s.ReadText(adReadAll);
	s.Close();
	*/

	return ret;
}
wget.prototype.getRespHeader = function (header, isCaseIgnored) {
	if(!isCaseIgnored){
		return this.xmlhttp.getResponseHeader(header);
	}
	var h = this.xmlhttp.getAllResponseHeaders();
	var re = new RegExp(header + ":\\s+(.*?)\\r\\n", "i");
	var matches = re.exec(h);
	return RegExp.$1;
}

// 2013-05-05 gzip defeat
wget.prototype.baspWget = function (url) {
	var TemporaryFolder = 2, ForReading = 1;
  tfolder = fso.GetSpecialFolder(TemporaryFolder);
  tname = fso.GetTempName();

	var rc = basp.W3get("-d " + tfolder + " -o " + tname
		+ " -l " + tname + ".log " + url);
	var ts, ret;
	if(rc == 1){
		ts = fso.OpenTextFile(tfolder + "\\" + tname, ForReading, true);
		ret = ts.Readall();
		ts.Close();
	}else{
		ts = fso.OpenTextFile(tfolder + "\\" + tname + ".log", ForReading, true);
		ret = "failed. " + ts.Readall();
		ts.Close();
	}
	if(fso.FileExists(tfolder + "\\" + tname)){
		fso.DeleteFile(tfolder + "\\" + tname, true);
	}
	if(fso.FileExists(tfolder + "\\" + tname + ".log")){
		fso.DeleteFile(tfolder + "\\" + tname + ".log", true);
	}
	return ret;
}

wget.prototype.str2byteArray = function (str) {
	var	s = new ActiveXObject("ADODB.Stream");
	s.Mode = 3 // 2: adModeWrite, 3: adModeReadWrite
	s.Type = 2;   // 1:adTypeBinary, 2:adTypeText
	s.charset = "iso-8859-1";
	s.Open();
	s.WriteText(str);
	s.Position = 0;
	s.Type = 1;   // 1:adTypeBinary 2:adTypeText
	var b = s.Read();
	s.Close();
	return b;
}

//
// wget object }
//

function createOAuth(){
// *********************
// oauth.js {
// *********************
/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here's some JavaScript software for implementing OAuth.

   This isn't as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: "GET", action: "http://server.com/path", parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [["a", 1], ["b", 2], ["a", 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: "GET", action: "http://server/path", parameters: {p: "x y"}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn't a valid OAuth request, since it lacks a signature etc.)
   Note that the object "x y" is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn't percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   <script src="oauth.js?oauth_timestamp=<?=time()?>" ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null && from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return "";
        }
        if (s instanceof Array) {
            var e = "";
            for (var i = 0; i < s.length; ++s) {
                if (e != "") e += '&';
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn't do
        // encodeURIComponent ignores: - _ . ! ~ * ' ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, "%21");
        s = s.replace(/\*/g, "%2A");
        s = s.replace(/\'/g, "%27");
        s = s.replace(/\(/g, "%28");
        s = s.replace(/\)/g, "%29");
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, " ");
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != "object") {
            return OAuth.decodeForm(parameters + "");
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != "object") {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + ""));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p < parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = "";
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = "";
            if (form != "") form += '&';
            form += OAuth.percentEncode(list[p][0])
              +'='+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split('&');
        for (var n = 0; n < nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == "") {
                continue;
            }
            var equals = nvp.indexOf('=');
            var name;
            var value;
            if (equals < 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p < parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i < list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn't fill in every parameter.
        The accessor object should be like:
        {consumerKey:'foo', consumerSecret:'bar', accessorSecret:'nurn', token:'krelm', tokenSecret:'blah'}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = "GET";
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, "oauth_consumer_key", accessor.consumerKey || "");
        }
        if (map.oauth_token == null && accessor.token != null) {
            OAuth.setParameter(message, "oauth_token", accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, "oauth_version", "1.0");
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, "oauth_timestamp", OAuth.timestamp());
        OAuth.setParameter(message, "oauth_nonce", OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length > 0) {
                var q = url.indexOf('?');
                if (q < 0) newURL += '?';
                else       newURL += '&';
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = 'OAuth realm="' + OAuth.percentEncode(realm) + '"';
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p < list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf("oauth_") == 0) {
                header += ',' + OAuth.percentEncode(name) + '="' + OAuth.percentEncode(parameter[1]) + '"';
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || "oauth_timestamp";
        var scripts = document.getElementsByTagName('script');
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf("?");
        if (q < 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = "";
        for (var i = 0; i < length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null && previous != null) {
        for (var key in previous) {
            if (key != "prototype") {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, "SignatureMethod", function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, "oauth_signature", signature);
        return signature; // just in case someone's interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            && name.length > 9
            && name.substring(name.length-9) == "-Accessor")
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +"&"+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: "lakjsdflkj...", consumerSecret: "QOUEWRI..", accessorSecret: "xcmvzc..."}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == "") {
            name = "HMAC-SHA1";
            OAuth.setParameter(message, "oauth_signature_method", name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error("signature_method_rejected");
        var acceptable = "";
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != "") acceptable += '&';
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n < names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren't any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf('?');
        var parameters;
        if (q < 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a < toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +'&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +'&'+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == "http" && uri.port == 80)
                    || (scheme == "https" && uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(":");
            if (index >= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = "/"; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + "://" + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || "";
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return "";
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p < list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != "oauth_signature") {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + " " // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] < b[0]) return  -1;
                          if (a[0] > b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s < sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass(["PLAINTEXT", "PLAINTEXT-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass(["HMAC-SHA1", "HMAC-SHA1-Accessor"],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = '=';
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}

// *********************
// end of oauth.js }
// *********************
	return OAuth;
}

function doTweet(mono){
	//
	// twitterに投稿(kurobot)
	//

	// POST メソッドで接続する先の URL |
	var action = "https://api.twitter.com/1.1/statuses/update.json";
	// 渡すパラメータ |
	/*
	var parameters = [
		[ "screen_name", "XXXXXX" ],
		[ "since_id", "XXXXXX" ],
	];
	*/
	var parameters = [
		[ "status", mono ]
	];

	// consumer key などの設定 |
	var accessor = {
		consumerKey    : "xxxxxxxxxxxxxxxxxxxxx",
		consumerSecret : "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
		token          : "xxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
		tokenSecret    : "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
	};

	// OAuthオブジェクトの生成
	var OAuth = createOAuth();

	// メッセージオブジェクトの生成 |
	var message = { method: "POST", action: action, parameters: parameters };
	// リクエスト本文の生成 |
	var requestBody = OAuth.formEncode( message.parameters );
	// OAuth 認証のためのパラメータ等の補完 (リクエスト本文の生成の後にすること) |
	OAuth.completeRequest( message, accessor );

	var w, c, t;
	try{
		var realm = "";
		w = new wget(message.method, message.action, requestBody
			, {"Accept": "text/*", "Accept-Encoding": "deflate"
				, "Content-Type": "application/x-www-form-urlencoded"
				, "Authorization": OAuth.getAuthorizationHeader(realm, message.parameters)}
			);

		c = w.getRespText();

		// when gzip returned, then exception occured
		// eval("var j = " + c + ";");

		if(/200 OK/.test(w.statusText)){
			//w.save("2saved.txt", false);
			//t = j[0].text;
		}else{
			throw new Error(-1, w.statusText);
		}

		t = "ok.";

	}catch(e){
		t = "failed. " + e.name + ": resp=" + c + ": desc=" + e.description;
		//WScript.Echo(t);
		w.save("2saved.txt", false);
	}
	delete w;
	return t;
}

function getTweetByUser(user, count){
	var action = "https://api.twitter.com/1.1/statuses/user_timeline.json?"
	+ "screen_name=" + user
	+ "&count=1";
	var parameters = [];

	// consumer key などの設定 |
	var accessor = {
		consumerKey    : "JMSMekIwchJBImPAsHrpg",
		consumerSecret : "Kg4leOuIn2aptNkkMnoU3oTrqUZB9eLSsu7wqXuMWA",
		token          : "150972543-mowZtEu48tsbOqEeVGbBvNjwsB5gE6zgJ6zLFC8c",
		tokenSecret    : "uz4mafmWsXeX7vv735EF2asqyXAwpanbYmv6SBoiZs"
	};

	// OAuthオブジェクトの生成
	var OAuth = createOAuth();

	// メッセージオブジェクトの生成 |
	var message = { method: "GET", action: action, parameters: parameters };
	// リクエスト本文の生成 |
	var requestBody = OAuth.formEncode( message.parameters );
	// OAuth 認証のためのパラメータ等の補完 (リクエスト本文の生成の後にすること) |
	OAuth.completeRequest( message, accessor );
	var w;
	var t = "";
	var c = "";
	try{

		var realm = "";
		// its gzip use-less
		w = new wget(message.method, message.action, ""
		, {"Accept": "text/*", "Accept-Encoding": "deflate"
		, "Authorization": OAuth.getAuthorizationHeader(realm, message.parameters)}
		);
		c = w.getRespText();
		eval("var j = " + c + ";");
		if(/200 OK/.test(w.statusText)){
			var t = j[0].text;
		}else{
			throw new Error(-1, w.statusText);
		}

	}catch(e){
		//WScript.Echo(e.name + ":" + e.description);
		t = "failed. " + e.name + ": resp=" + c + ": desc=" + e.description;
	}
	delete w;
	return t;
}

function translateText(mono, toLang){
	/*
	 * toLang: en: english
	 */
	var URL = 'http://api.microsofttranslator.com/v2/ajax.svc/TranslateArray2?appId="__APPID__"&texts=["'
	+ mono 
	+ '"]&from="ja"&to="'
	+ toLang + '"&oncomplete=_mstc1&onerror=_mste1&loc=ja&ctr=&rgp=d53b0ed';

	var w, c;
	try{
		var URL1 = 'http://www.bing.com/translator/';
		w = new wget("GET", URL1);
		c = w.getRespText();
		
		var re = new RegExp("Default\\.Constants\\.RTTAppID\\s*=\\s*'(.+?)';", "im");
		var matches = re.exec(c);
		var appid =  RegExp.$1;
		delete w;

		if(!appid){
			c = "[trucated]";
			throw new Error(-1, "appId is unrecognized");
		}

		URL = URL.replace(/__APPID__/, appid);

		/**/
		w = new wget("GET", URL);
		c = w.getRespText();

		//WScript.Echo("c=" + c);

		// convert to json
		c = c.replace(/^.*?\[(.*)\].*?$/, "$1")
			.replace(/"(\w+)":/g, "$1:")
			.replace(/:\[(\d+)\]/g , ":$1")
			;
		eval("var j = " + c + ";");

		if(/200 OK/.test(w.statusText)){
			var t = j['TranslatedText'];
			var l = j['TranslatedTextSentenceLengths'];
			/*
			WScript.Echo("t=" + t + "\r\nl=" + l);
			WScript.Echo("c=" + c);
			*/
		}else{

			throw new Error(-1, w.statusText);
		}

	}catch(e){
		//WScript.Echo(e.name + ":" + e.description);
		t = "failed. " + e.name + ": resp=" + c + ": desc=" + e.description;
	}
	delete w;
	return t;
}

]]>
</script>


</component>
