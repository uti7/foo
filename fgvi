#!/bin/bash -f
set -f
function usage {
  cat << EOT | less
name:
  $myname - file traverser

synopsis:
  find DIR -name FILE ->  grep PATTERN ->  vim +/PATTERN/

usage:
  $myname [-d DIR] [-d DIR...] [-nNilxz] PATTERN [FILE...]
  $myname [-d DIR] [-d DIR...] [-nNilxz] -a PATTERN [-a PATTERN ...] [FILE...]
  $myname [-d DIR] [-d DIR...] [-nN] -L [FILE...]
  $myname [-d DIR] [-d DIR...] [-nN] -D [FILE...]

  -d DIR:      : a search-path, givens to find. if omited, then \`.'
  -D           : find target is only directory, and no grep forcely.
  -i           : ignore case, its applied the FILE as well as the PATTERN
  -l, -L       : no grep, do not mind any pattern (see below the note:)
  -n           : no vim, only output like grep
  -N           : ask whether open as vim, after output like grep
  -a PATTERN   : regular expression for all PATTERN(s) matching
                 (i.e. AND condition of them)
  -x           : output precedent line (e.g. php declaration) with grep results.
                 (see the variable \`default_precedent' what setting in \$HOME/.${myname}rc for details)
                 has no effect when no-grep opt (-l, -L) specified
  -z           : for .gz compressed file, zgrep is used instead of grep
  PATTERN      : a regular expression
  FILE         : basename of filename, also directory/.../filename available
                 if appear directory-spec at FILE, apply to search-path implied.
                 wildcard-char should be escaped
                 to avoid expand by shell. (e.g. \\*.txt)
                 if omited, then \`\\*'
note:
  if option -l (with) -n, or -l (with) -N are specified:
                 print only each file name which, like its \`grep -l'
                 however, -L is never grep

examples:

     $ $myname PATTERN foo\\*.xml
      its like, as:
        find . -name foo\\*.xml -print |
        vim \`grep -El PATTERN\` 

     $ $myname -d /etc PATTERN \\*.conf
      as:
        vim +/PATTERN/ \\
          \`find /etc -name \\*.conf -print0 | xargs -0  grep -El PATTERN\`

     $ $myname -nl \\*
      as:
        find . -name \\* -print

     $ $myname -l \\*bar.php
      as:
        vim \`find . -name \\*bar.php -print\`

     $ $myname -a foo -a bar /etc/\\*ini /var/log/\\*.log
      as:
        find /etc /var/log \\( -name \\*.ini -o -name \\*.log \\) \\
          -exec grep -Eq foo {} \\; -print | \\
        grep -EHn 'bar' | vim +/foo\\|bar 
EOT
}

function zrefrep
{
  re=$1
  shift
  x=1
  for zf in $*
  do
    zcat $zf | refrep $re
    [ $? -eq 0 ] && x=0
  done
  return $x
}

function refrep
{
  if [ -z "$default_precedent" ]; then
    #precedent='(class|function)\\s+\\w+' # no available exec on awk 3.x
    precedent='(class|function)[ \\t]+\\w+'
  else
    precedent="$default_precedent"
  fi
  re=$1
  shift
  files=$*
  [ -n "$ignore_case_opt" ] && ic=1
  gawk -v ic=${ic:-0} -v zf=${zf:-unknown} -v precedent="$precedent" -v re="$re" 'BEGIN{IGNORECASE=ic;x=1;preserve=""}{\
    if(match($0, precedent)>0){\
      fname = (FILENAME == "-") ? zf : FILENAME;\
      preserve = fname ":" FNR ":@@@@@:" $0;\
    }\
    if(match($0, re)>0){\
      if(preserve != ""){\
        print preserve;\
        preserve = "";\
      }\
      fname = (FILENAME == "-") ? zf : FILENAME;\
      print fname ":" FNR ":" $0;\
      x = 0;\
    }\
  }END{exit(x);}' $files
  return $?
}

function mkrc
{
  cat << EOT >"$HOME/.${myname}rc"
### default settings

## -d
#base_path="."

## 1: -n, 2: -N
#is_not_vi=2

## -i
#ignore_case_opt="-i"

## -l
#is_not_grep=1

## FILE
#default_file_spec="*"

## for -x
#default_precedent='(class|function|CREATE TABLE)[ \\t]+\\w+'
EOT
}

myname=${0//*\//}
vi=vim
grep=grep
refrep=refrep
name_opt="-name"
type_opt="f"

if [ ! -r "$HOME/.${myname}rc" ]; then
  mkrc
fi
. "$HOME/.${myname}rc"

while getopts 'a:d:DnNilLxz' opt
do
    case $opt in
    a)  reg_exp[${#reg_exp[@]}]="$OPTARG";;
    d)  base_path="${base_path:-} $OPTARG";;
    D)  type_opt="d"; is_not_grep=1;;
    n)
      is_not_vi=1
      [ ${is_not_grep:-0} -eq 1 ] && is_file_with_matches=1
      ;;
    N)
      is_not_vi=2
      [ ${is_not_grep:-0} -eq 1 ] && is_file_with_matches=1
      ;;
    i)  ignore_case_opt="-i";name_opt="-iname";;
    l)
      is_not_grep=1
      [ ${is_not_vi:-0} -gt 0 ] && is_file_with_matches=1
      ;;
    L)
      is_not_grep=1
      ;;
    x)  is_out_precedent=1;;
    z)  grep=zgrep;refrep=zrefrep;;
    *)  usage; exit 2;;
    esac
done

shift `expr $OPTIND - 1` 1>/dev/null 2>&1


[ ${is_file_with_matches:-0} -eq 1 ] && is_not_grep=0


if [ ${is_not_grep:-0} -eq 0 ] && [ -z "$reg_exp" ]; then
  reg_exp="$1"
  [ -z "$reg_exp" ] && usage && exit 2
  shift
fi

if [ $# -eq 0 ]; then
  # file is omited
  [ -z "$base_path" ] && base_path="."
  file_spec_org="${default_file_spec:-*}"
else
  file_spec_org=""
  if [ -z "$base_path" ]; then
    for f in $*
    do
      d=`dirname $f`
      if [ "$d" != "." ]; then
        base_path="$base_path $d"
      fi
      file_spec_org="$file_spec_org `basename $f`"
    done
    #base_path="${base_path:-.}"
  else
    for f in $*
    do
      file_spec_org="$file_spec_org `basename $f`"
    done
  fi
fi

#
# 1st filtering for ${reg_exp[0]} by find and grep
#

file_spec=""
for f in $file_spec_org
do
  if [ -z "$file_spec" ]; then
    file_spec="$name_opt $f"
  else
    file_spec="$file_spec  -o $name_opt $f"
  fi

  [ -z "$file_spec" ] && { usage; exit 2; }

done

file_spec="( $file_spec ) -a ( ! -name *.swp )"
if [ ${is_not_grep:-0} -eq 0 ]; then
  if [ "$grep" = "grep" ]; then
    matched=`find $base_path -type $type_opt $file_spec -print0 | xargs -0 $grep -El ${ignore_case_opt:-} "${reg_exp[0]}"`
  else
    # for zgrep, to know each filename because zgrep -H does not work.
    for f in `find $base_path -type $type_opt $file_spec -print`
    do
      $grep -Eq ${ignore_case_opt:-} "${reg_exp[0]}" $f
      [ $? -eq 0 ] && matched="$matched $f"
      
    done
  fi
  re4vi=`echo "${reg_exp[0]}"|sed -e 's#\([()?+|]\)#\\\\\1#g'`
  re4grep="${reg_exp[0]}"
else
  matched=`find $base_path -type $type_opt $file_spec -print`
fi
if [ -z "$matched" ]; then
  echo "${reg_exp[0]}: No matched."
  exit 1
fi

#
# filtering for each reg_exp by grep
#
if [ ${is_not_grep:-0} -eq 0 ]; then
  i=1
  while [ $i -lt "${#reg_exp[@]}" ]
  do
    matched_org=$matched
    matched=""
    for f in $matched_org
    do
      $grep -Eq ${ignore_case_opt:-} "${reg_exp[$i]}" $f
      [ $? -eq 0 ] && matched="$matched $f"
    done
    if [ -z "$matched" ]; then
      echo "${reg_exp[$i]}: No matched."
      exit 1
    fi

    r=`echo "${reg_exp[$i]}" |sed -e 's#\([()?+|]\)#\\\\\1#g'`
    re4vi="$re4vi\|$r"
    re4grep="$re4grep|${reg_exp[$i]}"
    i=$(( i + 1 ))
  done
  [ -n "$ignore_case_opt" ] && re4vi="\(${re4vi}\)\c"
fi

#
# action
#
if [ ${is_not_vi:-0} -gt 0 ]; then
  if [ ${is_not_grep:-0} -eq 0 ]; then
    if [ ${is_out_precedent:-0} -eq 0 ] && [ ${is_file_with_matches:-0} -eq 0 ]
    then
      $grep -EHn ${ignore_case_opt:-} "$re4grep" $matched
    elif [ ${is_file_with_matches:-0} -eq 1 ]; then
      $grep -El ${ignore_case_opt:-} "$re4grep" $matched
    else
      $refrep "$re4grep" $matched
    fi
    x=$?
  else
    x=1
    for f in $matched
    do
      echo $f
      x=0
    done
  fi
  if [ ${is_not_vi:-0} -gt 1 ]; then
    echo -n "will open as vim, ok?(y/n):"
    read Q
    [ "$Q" != 'y' ] && exit "$x"
    is_not_vi=0
  fi
fi

if [ ${is_not_vi:-0} -eq 0 ]; then
  if [ ${is_not_grep:-0} -eq 0 ]; then
    exec $vi "+/$re4vi/" $matched
  else
    exec $vi $matched
  fi
fi
exit $x
